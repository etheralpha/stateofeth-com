{%- assign chart_id = "consensusClientDivarsityValidators" -%}
{%- assign blockprint = site.data.metrics.consensus-client-diversity-validators.blockprint -%}
{%- assign data = blockprint -%}
{%- capture source -%}
Data provided by <a href="https://github.com/sigp/blockprint/blob/main/docs/api.md">Sigma Prime's Blockprint</a> â€” updated daily
{%- endcapture -%}


{%- capture js -%}
  <script type="text/javascript">
    let {{chart_id}}_labels = [];

    // create array of labels
    {{chart_id}}_data.forEach(item => {
      item.data.distribution.forEach(client => {
        if (!{{chart_id}}_labels.includes(client.name)) {
          {{chart_id}}_labels.push(client.name);
        }
      });
    });

    // fill in missing data
    {{chart_id}}_data.forEach(item => {
      let client_exists = false;
      {{chart_id}}_labels.forEach(clientName => {
        if (item.data.distribution.find(client => client.name === clientName)) {
          client_exists = true;
        } else {
          item.data.distribution.push({"name":clientName,"value":undefined});
          log(`No data for ${clientName} on ${item.date}`);
        }
        client_exists = false;
      })
    });

    // create chart datasets
    {{chart_id}}_labels.forEach(function (label, i) {
      let dataset_data = {{chart_id}}_data.map(item => Math.round( item.data.distribution.filter(client => client.name == label)[0].value * 10000)/100);

      {{chart_id}}.data.datasets[i] = {
        label: label[0].toUpperCase() + label.slice(1),
        data: dataset_data,
        data_all: dataset_data,
        yAxisID: 'y',
        fill: {{chart_id}}_fill,
        pointStyle: {{chart_id}}_pointStyle
      };
    });

    // create y-tick callback
    {{chart_id}}.options.scales.y.ticks.callback = function(value) {
      return `${value}%`;
    };

    // update chart
    {{chart_id}}.update();
  </script>
{%- endcapture -%}


{% include components/data-line-chart.html
  chart_id=chart_id
  data=data
  js=js
  source=source
%}
